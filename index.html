<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF Whiteboard - Sync Drawing with Recording + Telegram Storage</title>
  
  <!-- MathJax for Math Equations -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true
      }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" async></script>
  
  <!-- QR Code Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  
  <style>
    body {
      margin: 0;
      font-family: Arial;
      background: #f5f5f5;
      height: 100vh;
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 10px;
      box-sizing: border-box;
    }
    
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      padding: 10px;
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      margin-bottom: 10px;
      align-items: center;
    }
    
    .tool-group {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    
    .toolbar button, .toolbar a.btn {
      padding: 8px 12px;
      border: none;
      border-radius: 5px;
      background: #0b79f7;
      color: white;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.2s;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    .toolbar button:hover, .toolbar a.btn:hover {
      background: #0a6ad8;
    }
    
    .toolbar button.secondary, .toolbar a.btn.secondary {
      background: #f0f0f0;
      color: #333;
    }
    
    .toolbar button.secondary:hover, .toolbar a.btn.secondary:hover {
      background: #e0e0e0;
    }
    
    .toolbar button.active {
      background: #2196f3;
      color: white;
    }
    
    .toolbar button.adj-active {
      background: #ff9800;
      color: white;
    }
    
    .toolbar button.sync-active {
      background: #9c27b0;
      color: white;
    }
    
    .toolbar button.clear-active {
      background: #f44336;
      color: white;
    }
    
    .toolbar button.telegram-btn {
      background: #0088cc;
    }
    
    .toolbar button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .boardBox {
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      padding: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      position: relative;
    }
    
    .pdf-container, .canvas-container {
      position: relative;
      width: 100%;
      height: 0;
      padding-bottom: 56.25%;
    }
    
    #topPdf {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 10px;
      background: white;
      border: 2px solid #ddd;
    }
    
    #mainBoard {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 10px;
      background: white;
      touch-action: none;
      border: 2px solid #ddd;
    }
    
    h2 {
      margin: 0 0 8px 0;
      font-size: 18px;
    }
    
    .instructions {
      background: #e3f2fd;
      padding: 10px;
      border-radius: 5px;
      margin-top: 5px;
      font-size: 14px;
    }
    
    .color-picker {
      display: flex;
      gap: 5px;
      align-items: center;
    }
    
    .color-option {
      width: 25px;
      height: 25px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
    }
    
    .color-option.active {
      border-color: #333;
    }
    
    .custom-color-container {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    .custom-color-input {
      width: 30px;
      height: 30px;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      background: #000000;
    }
    
    .file-input {
      display: none;
    }
    
    .file-label {
      padding: 8px 12px;
      background: #4caf50;
      color: white;
      border-radius: 5px;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .file-label:hover {
      background: #45a049;
    }
    
    .history-buttons {
      display: flex;
      gap: 5px;
    }
    
    .brush-size {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    .brush-size input {
      width: 80px;
    }
    
    .pdf-controls {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-left: auto;
    }
    
    .pdf-controls span {
      font-size: 14px;
    }
    
    .pdf-resize-controls {
      display: flex;
      align-items: center;
      gap: 5px;
      background: #e3f2fd;
      padding: 8px 12px;
      border-radius: 5px;
      margin-left: 10px;
    }
    
    .pdf-resize-controls button {
      padding: 6px 10px;
      background: #2196f3;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }
    
    .pdf-info {
      background: #e8f5e8;
      padding: 8px 12px;
      border-radius: 5px;
      font-size: 14px;
      margin-top: 5px;
    }
    
    .adj-status {
      background: #fff3cd;
      padding: 8px 12px;
      border-radius: 5px;
      font-size: 14px;
      margin-top: 5px;
      border-left: 4px solid #ff9800;
      display: none;
    }
    
    .sync-status {
      background: #f3e5f5;
      padding: 8px 12px;
      border-radius: 5px;
      font-size: 14px;
      margin-top: 5px;
      border-left: 4px solid #9c27b0;
      display: none;
    }
    
    .loading {
      background: #fff3cd;
      padding: 8px 12px;
      border-radius: 5px;
      font-size: 14px;
      margin-top: 5px;
      border-left: 4px solid #ff9800;
      display: none;
    }
    
    .status-indicator {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: rgba(0,0,0,0.6);
      color: white;
      padding: 5px 7px;
      border-radius: 5px;
      font-size: 12px;
      z-index: 100;
    }
    
    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 8px;
      background: #f8f9fa;
      border-radius: 5px;
    }
    
    input[type="color"] {
      width: 40px;
      height: 30px;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
    }
    
    input[type="range"] {
      width: 80px;
    }
    
    /* Telegram Storage Panel */
    .telegram-panel {
      background: #0088cc;
      color: white;
      padding: 10px 15px;
      border-radius: 5px;
      margin-top: 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .telegram-status {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    /* Math Input Section */
    .math-input-section {
      margin-top: 10px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 5px;
    }
    
    #mathInput {
      width: 100%;
      padding: 8px;
      margin: 5px 0;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    
    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    
    .modal-content {
      background: white;
      padding: 20px;
      border-radius: 10px;
      max-width: 400px;
      width: 90%;
      text-align: center;
    }
    
    /* Recording Indicator */
    .recording-indicator {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #dc3545;
      color: white;
      padding: 10px 15px;
      border-radius: 50px;
      font-weight: bold;
      animation: pulse 1.5s infinite;
      display: none;
      z-index: 1000;
    }
    
    @keyframes pulse {
      0% { opacity: 0.7; }
      50% { opacity: 1; }
      100% { opacity: 0.7; }
    }
    
    /* Mic Status Indicator */
    #micStatusIndicator {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: #4caf50;
      color: white;
      padding: 10px 15px;
      border-radius: 5px;
      font-weight: bold;
      z-index: 1000;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      animation: fadeInOut 5s ease-in-out;
      display: none;
    }
    
    @keyframes fadeInOut {
      0% { opacity: 0; transform: translateY(20px); display: block; }
      10% { opacity: 1; transform: translateY(0); }
      90% { opacity: 1; transform: translateY(0); }
      100% { opacity: 0; transform: translateY(20px); display: none; }
    }
    
    /* Screen Recording Canvas */
    #recordingCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 1280px;
      height: 720px;
      z-index: -9999;
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>
<body>

<!-- Hidden Canvas for Recording -->
<canvas id="recordingCanvas"></canvas>

<!-- Recording Indicator -->
<div class="recording-indicator" id="recordingIndicator">
  üî¥ RECORDING TO TELEGRAM
</div>

<!-- Mic Status Indicator -->
<div id="micStatusIndicator"></div>

<!-- QR Code Modal -->
<div class="modal" id="qrModal">
  <div class="modal-content">
    <h3>üì± Mobile Access</h3>
    <p>Scan QR to access recordings in Telegram:</p>
    <div id="qrCodeContainer"></div>
    <p style="margin: 10px 0; color: #666;">
      Or open: <strong>t.me/WB27_bot</strong>
    </p>
    <button onclick="closeModal('qrModal')" style="padding: 8px 15px; background: #0088cc; color: white; border: none; border-radius: 5px; cursor: pointer;">
      ‚úÖ Done
    </button>
  </div>
</div>

<!-- Telegram Storage Panel -->
<div class="telegram-panel" id="telegramPanel">
  <div class="telegram-status">
    <span>‚òÅÔ∏è Telegram Storage: </span>
    <span id="telegramStatusText">‚úÖ Connected</span>
  </div>
  <div>
    <button onclick="showQRCode()" style="background: white; color: #0088cc; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">
      üì± Open in Telegram
    </button>
  </div>
</div>

<div class="toolbar">
  <div class="control-group">
    <input type="color" id="color" value="#000000" title="Pen Color">
    <input type="range" id="brushSize" min="1" max="40" value="3" title="Brush Size">
    <span id="brushSizeValue">3px</span>
  </div>
  
  <div class="tool-group">
    <button id="drawBtn" class="active">‚úèÔ∏è Draw</button>
    <button id="eraseBtn" class="secondary">üßΩ Eraser</button>
    <button id="smartEraseBtn" class="secondary">üéØ Smart Erase</button>
    <button id="clearBtn" class="secondary clear-active">üóëÔ∏è Clear</button>
    <button id="undoBtn" class="secondary">‚Ü©Ô∏è Undo</button>
    <button id="redoBtn" class="secondary">‚Ü™Ô∏è Redo</button>
    <button id="adjBtn" class="secondary">üîß ADJ</button>
    <button id="syncBtn" class="secondary">üîÑ SYNC</button>
    <button id="resetAdjBtn" class="secondary">üîÑ Reset ADJ</button>
  </div>
  
  <!-- Microphone Controls -->
  <div class="tool-group">
    <button id="micTestBtn" class="telegram-btn" style="background: #4caf50;">
      üé§ Test Microphone
    </button>
    <button id="enableMicBtn" class="telegram-btn" style="background: #2196f3;">
      üîä Enable Microphone
    </button>
  </div>
  
  <div class="tool-group">
    <button id="recordBtn" style="background: #dc3545;">
      <span id="recordIcon">üî¥</span>
      <span id="recordText">Record with Audio + Save to Telegram</span>
    </button>
    <button class="telegram-btn" onclick="testTelegram()">ü§ñ Test Telegram</button>
  </div>
  
  <input type="file" id="pdfUpload" class="file-input" accept=".pdf">
  <label for="pdfUpload" class="file-label">üìÑ Upload PDF</label>
  
  <div class="pdf-controls" id="pdfControls" style="display: none;">
    <button id="prevPageBtn" class="secondary">‚óÄ Prev</button>
    <span id="pageInfo">Page 1/1</span>
    <button id="nextPageBtn" class="secondary">Next ‚ñ∂</button>
  </div>
</div>

<!-- Math Input Section -->
<div class="math-input-section">
  <strong>üìù Math Equations:</strong>
  <input type="text" id="mathInput" placeholder="Enter math in LaTeX: $x^2 + y^2 = r^2$">
  <button onclick="addMathEquation()" style="padding: 5px 10px; background: #4caf50; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 5px;">
    Add Math to Canvas
  </button>
</div>

<div id="pdfInfo" class="pdf-info" style="display: none;">
  ‚úÖ PDF loaded successfully! You can now draw on both canvases.
</div>

<div id="adjStatus" class="adj-status">
  üîß ADJ Mode Active: You can now zoom/pan only the top PDF with pinch gestures
</div>

<div id="syncStatus" class="sync-status">
  üîÑ SYNC Mode Active: Both views will sync automatically
</div>

<div id="loading" class="loading">
  ‚è≥ Loading PDF page...
</div>

<h2>üìå PDF View (Reference + Drawing) <span id="topPdfStatus"></span></h2>
<div class="boardBox">
  <div class="pdf-container" id="topPdfContainer">
    <canvas id="topPdf"></canvas>
    <div id="topCanvasStatus" class="status-indicator">Ready</div>
  </div>
</div>

<h2>‚úçÔ∏è Drawing Canvas (Zoom + Pan + Draw) <span id="mainBoardStatus"></span></h2>
<div class="boardBox">
  <div class="canvas-container" id="mainCanvasContainer">
    <canvas id="mainBoard"></canvas>
  </div>
</div>

<div class="instructions">
  <strong>Instructions:</strong> 
  ‚Ä¢ Top: PDF Reference View + Drawing (Recording available)
  ‚Ä¢ Bottom: Drawing Canvas (Zoom with pinch gesture ‚Ä¢ Pan with two fingers ‚Ä¢ Draw with one finger/mouse)
  ‚Ä¢ Drawing will appear on both canvases simultaneously
  ‚Ä¢ Use ADJ button to adjust top PDF ‚Ä¢ SYNC button to sync both views
  ‚Ä¢ Smart Erase to remove complete strokes
  ‚Ä¢ Click "Test Microphone" to enable audio recording
  ‚Ä¢ Record button to record top canvas with audio and auto-save to Telegram
  ‚Ä¢ Math equations can be added using LaTeX syntax
</div>

<!-- Include PDF.js library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>

<script>
// Set PDF.js worker path
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

// ============================================
// TELEGRAM CONFIGURATION - FATHERBOT SUPPORT
// ============================================
const TELEGRAM_CONFIG = {
  BOT_TOKEN: '8142735342:AAHexGW7ZVeWorAb70i51P1hudv9rljUH7Q',
  CHAT_ID: '5229323108',
  BOT_USERNAME: 'WB27_bot',
  USE_FATHERBOT: true, // Enable FatherBot
  FATHERBOT_ENDPOINT: 'https://fatherbot.vercel.app/api/telegram'
};

// ============================================
// MICROPHONE RECORDING SETUP
// ============================================
let audioStream = null;
let audioTrack = null;
let isMicEnabled = false;

// ============================================
// FIXED SCREEN RECORDING SYSTEM
// ============================================
const recordingCanvas = document.getElementById('recordingCanvas');
const recordingCtx = recordingCanvas.getContext('2d');

// Recording variables
let recorder = null;
let recordedChunks = [];
let isRecording = false;
let recordingInterval = null;
let recordingStream = null;

// ============================================
// MICROPHONE FUNCTIONS
// ============================================

// Microphone ‡§ü‡•á‡§∏‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç
async function testMicrophone() {
  try {
    // ‡§™‡§π‡§≤‡•á ‡§Æ‡§æ‡§á‡§ï permission ‡§ö‡•á‡§ï ‡§ï‡§∞‡•á‡§Ç
    try {
      const permissionStatus = await navigator.permissions.query({ name: 'microphone' });
      
      if (permissionStatus.state === 'denied') {
        alert('‚ùå Microphone access is blocked. Please allow microphone access in your browser settings.');
        return;
      }
    } catch (permError) {
      console.log('Permission query not supported');
    }
    
    // ‡§™‡•â‡§™‡§Ö‡§™ ‡§¶‡§ø‡§ñ‡§æ‡§è‡§Ç
    alert('üé§ Please allow microphone access in the next popup to test your microphone.');
    
    // ‡§Æ‡§æ‡§á‡§ï access ‡§ï‡•á ‡§≤‡§ø‡§è request ‡§ï‡§∞‡•á‡§Ç
    audioStream = await navigator.mediaDevices.getUserMedia({ 
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true
      }
    });
    
    audioTrack = audioStream.getAudioTracks()[0];
    
    if (audioTrack) {
      isMicEnabled = true;
      alert('‚úÖ Microphone test successful! Your microphone is working.\n\nDevice: ' + audioTrack.label);
      
      // Update button text
      document.getElementById('enableMicBtn').innerHTML = '‚úÖ Mic Enabled';
      document.getElementById('enableMicBtn').style.background = '#4caf50';
      
      // Show mic status indicator
      showMicStatus('üé§ Microphone Test Successful!');
      
      // Stop the stream after test
      setTimeout(() => {
        if (audioStream) {
          audioStream.getTracks().forEach(track => track.stop());
          audioStream = null;
        }
      }, 1000);
    }
    
  } catch (error) {
    console.error('Microphone test error:', error);
    alert('‚ùå Microphone access failed: ' + error.message + '\n\nPlease make sure you allow microphone access when prompted.');
  }
}

// Recording ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡§æ‡§á‡§ï enable ‡§ï‡§∞‡•á‡§Ç
async function enableMicrophoneForRecording() {
  try {
    // ‡§™‡§π‡§≤‡•á ‡§∏‡•á enabled ‡§π‡•à ‡§§‡•ã disable ‡§ï‡§∞‡•á‡§Ç
    if (isMicEnabled) {
      if (audioStream) {
        audioStream.getTracks().forEach(track => track.stop());
      }
      isMicEnabled = false;
      audioStream = null;
      audioTrack = null;
      
      document.getElementById('enableMicBtn').innerHTML = 'üîä Enable Microphone';
      document.getElementById('enableMicBtn').style.background = '#2196f3';
      showMicStatus('üîá Microphone Disabled');
      return;
    }
    
    // Permission check
    try {
      const permissionStatus = await navigator.permissions.query({ name: 'microphone' });
      
      if (permissionStatus.state === 'denied') {
        alert('‚ùå Microphone access is blocked. Please:\n1. Click the lock icon in your browser address bar\n2. Click "Site settings"\n3. Allow microphone access');
        return;
      }
    } catch (permError) {
      console.log('Permission query not supported');
    }
    
    // ‡§™‡•â‡§™‡§Ö‡§™ ‡§¶‡§ø‡§ñ‡§æ‡§è‡§Ç
    alert('üé§ Please allow microphone access in the next popup to enable audio recording.');
    
    // ‡§Æ‡§æ‡§á‡§ï access ‡§ï‡•á ‡§≤‡§ø‡§è request ‡§ï‡§∞‡•á‡§Ç
    audioStream = await navigator.mediaDevices.getUserMedia({ 
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true,
        sampleRate: 44100
      }
    });
    
    audioTrack = audioStream.getAudioTracks()[0];
    
    if (audioTrack) {
      isMicEnabled = true;
      
      // Update button
      document.getElementById('enableMicBtn').innerHTML = '‚úÖ Mic Enabled';
      document.getElementById('enableMicBtn').style.background = '#4caf50';
      
      // Show mic status indicator
      showMicStatus('üé§ Microphone Enabled for Recording');
      
      alert('‚úÖ Microphone enabled for recording!\n\nNow when you record, audio will be included in the video.');
    }
    
  } catch (error) {
    console.error('Enable microphone error:', error);
    alert('‚ùå Failed to enable microphone: ' + error.message);
  }
}

// ‡§Æ‡§æ‡§á‡§ï ‡§∏‡•ç‡§ü‡•á‡§ü‡§∏ ‡§á‡§Ç‡§°‡§ø‡§ï‡•á‡§ü‡§∞ ‡§¶‡§ø‡§ñ‡§æ‡§è‡§Ç
function showMicStatus(message) {
  const indicator = document.getElementById('micStatusIndicator');
  indicator.textContent = message;
  indicator.style.display = 'block';
  
  // 5 ‡§∏‡•á‡§ï‡§Ç‡§° ‡§¨‡§æ‡§¶ ‡§π‡§ü‡§æ‡§è‡§Ç
  setTimeout(() => {
    indicator.style.display = 'none';
  }, 5000);
}

// Audio ‡§ï‡•á ‡§∏‡§æ‡§• ‡§∞‡§ø‡§ï‡•â‡§∞‡•ç‡§°‡§ø‡§Ç‡§ó ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç
async function startScreenRecordingWithAudio() {
  try {
    // Check if microphone is enabled
    if (!isMicEnabled) {
      const useAudio = confirm('üé§ Microphone is not enabled.\n\nDo you want to:\n1. Enable microphone and record WITH audio?\n2. Record WITHOUT audio?');
      
      if (useAudio) {
        // Enable microphone first
        await enableMicrophoneForRecording();
        if (!isMicEnabled) {
          // User didn't enable mic, record without audio
          return startScreenRecordingWithoutAudio();
        }
      } else {
        // Record without audio
        return startScreenRecordingWithoutAudio();
      }
    }
    
    // Start recording with audio
    document.getElementById('recordingIndicator').style.display = 'block';
    document.getElementById('recordIcon').textContent = "‚èπÔ∏è";
    document.getElementById('recordText').textContent = "Stop Recording";
    document.getElementById('recordBtn').style.background = "#28a745";
    document.getElementById('topCanvasStatus').textContent = "üé• Starting recording with audio...";
    
    // Clear previous recording
    recordedChunks = [];
    
    // Method 1: Try CANVAS recording with audio
    if (!await startCanvasCaptureWithAudio()) {
      // Method 2: Try screen recording as fallback
      if (!await startDisplayCaptureWithAudio()) {
        throw new Error('Recording not supported');
      }
    }
    
    isRecording = true;
    
    alert('üé• Recording started WITH AUDIO!\nYou can now draw and speak on the canvas.\nClick STOP button when finished.');
    
  } catch (error) {
    console.error('Recording with audio error:', error);
    alert('Recording with audio failed: ' + error.message + '\nTrying without audio...');
    startScreenRecordingWithoutAudio();
  }
}

// Audio ‡§ï‡•á ‡§¨‡§ø‡§®‡§æ ‡§∞‡§ø‡§ï‡•â‡§∞‡•ç‡§°‡§ø‡§Ç‡§ó ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç (original function)
async function startScreenRecordingWithoutAudio() {
  try {
    document.getElementById('recordingIndicator').style.display = 'block';
    document.getElementById('recordIcon').textContent = "‚èπÔ∏è";
    document.getElementById('recordText').textContent = "Stop Recording";
    document.getElementById('recordBtn').style.background = "#28a745";
    document.getElementById('topCanvasStatus').textContent = "üé• Starting recording...";
    
    recordedChunks = [];
    
    // Method 1: Try CANVAS recording
    if (!await startCanvasCapture()) {
      // Method 2: Try screen recording as fallback
      if (!await startDisplayCapture()) {
        throw new Error('Recording not supported');
      }
    }
    
    isRecording = true;
    
    alert('üé• Recording started WITHOUT audio!\nYou can now draw on the canvas.\nClick STOP button when finished.');
    
  } catch (error) {
    console.error('Recording error:', error);
    alert('Recording failed: ' + error.message + '\nUsing screenshot instead.');
    saveScreenshotToTelegram();
  }
}

// Canvas capture with audio
async function startCanvasCaptureWithAudio() {
  try {
    recordingCanvas.width = topPdf.width || 1280;
    recordingCanvas.height = topPdf.height || 720;
    
    recordedChunks = [];
    
    // Get audio stream if enabled
    let audioStreamForRecording = null;
    if (isMicEnabled) {
      try {
        audioStreamForRecording = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        });
      } catch (audioError) {
        console.warn('Audio stream error:', audioError);
        isMicEnabled = false;
      }
    }
    
    // Create canvas stream
    const canvasStream = recordingCanvas.captureStream(15);
    recordingStream = canvasStream;
    
    // Combine streams if audio is available
    if (audioStreamForRecording) {
      recordingStream = new MediaStream([
        ...canvasStream.getVideoTracks(),
        ...audioStreamForRecording.getAudioTracks()
      ]);
    }
    
    const mimeType = MediaRecorder.isTypeSupported('video/webm; codecs=vp9,opus') 
      ? 'video/webm; codecs=vp9,opus'
      : MediaRecorder.isTypeSupported('video/webm')
      ? 'video/webm'
      : 'video/mp4';
    
    const options = {
      mimeType: mimeType,
      videoBitsPerSecond: 1000000
    };
    
    // Add audio bits if available
    if (audioStreamForRecording) {
      options.audioBitsPerSecond = 128000;
    }
    
    recorder = new MediaRecorder(recordingStream, options);
    
    recorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        recordedChunks.push(event.data);
      }
    };
    
    recorder.onstop = async () => {
      if (recordedChunks.length > 0) {
        const blob = new Blob(recordedChunks, { type: mimeType });
        await saveRecordingToTelegram(blob);
      }
      
      // Stop all tracks
      if (recordingStream) {
        recordingStream.getTracks().forEach(track => track.stop());
        recordingStream = null;
      }
    };
    
    recorder.start(100);
    
    // Start capturing frames
    recordingInterval = setInterval(() => {
      captureCanvasFrame();
    }, 1000 / 15);
    
    return true;
    
  } catch (error) {
    console.error('Canvas capture with audio error:', error);
    return false;
  }
}

// Display capture with audio
async function startDisplayCaptureWithAudio() {
  try {
    const displayMediaOptions = {
      video: {
        cursor: "always",
        width: { ideal: 1280 },
        height: { ideal: 720 }
      },
      audio: false // We'll add audio separately
    };
    
    const screenStream = await navigator.mediaDevices.getDisplayMedia(displayMediaOptions);
    
    // Get audio stream if enabled
    let audioStreamForRecording = null;
    if (isMicEnabled) {
      try {
        audioStreamForRecording = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true
          }
        });
      } catch (audioError) {
        console.warn('Audio stream error:', audioError);
      }
    }
    
    // Combine streams
    let combinedStream = screenStream;
    if (audioStreamForRecording) {
      combinedStream = new MediaStream([
        ...screenStream.getVideoTracks(),
        ...audioStreamForRecording.getAudioTracks()
      ]);
    }
    
    recordingStream = combinedStream;
    recordedChunks = [];
    
    const mimeType = MediaRecorder.isTypeSupported('video/webm; codecs=vp9,opus') 
      ? 'video/webm; codecs=vp9,opus'
      : 'video/webm';
    
    const options = {
      mimeType: mimeType,
      videoBitsPerSecond: 1000000
    };
    
    if (audioStreamForRecording) {
      options.audioBitsPerSecond = 128000;
    }
    
    recorder = new MediaRecorder(combinedStream, options);
    
    recorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        recordedChunks.push(event.data);
      }
    };
    
    recorder.onstop = async () => {
      const blob = new Blob(recordedChunks, { type: mimeType });
      await saveRecordingToTelegram(blob);
      
      if (recordingStream) {
        recordingStream.getTracks().forEach(track => track.stop());
        recordingStream = null;
      }
    };
    
    recorder.start(100);
    return true;
    
  } catch (error) {
    console.error('Display capture with audio error:', error);
    return false;
  }
}

// ============================================
// TELEGRAM STORAGE FUNCTIONS - FIXED
// ============================================
async function uploadToTelegram(blob, fileName, type = 'video') {
  try {
    document.getElementById('topCanvasStatus').textContent = 'üì§ Uploading to Telegram...';
    
    let result = false;
    
    // First try FatherBot
    if (TELEGRAM_CONFIG.USE_FATHERBOT) {
      result = await uploadToFatherBot(blob, fileName, type);
    }
    
    // If FatherBot fails, try direct Telegram API
    if (!result) {
      result = await uploadToDirectTelegram(blob, fileName, type);
    }
    
    return result;
    
  } catch (error) {
    console.error('Telegram upload error:', error);
    document.getElementById('topCanvasStatus').textContent = '‚ùå Upload failed';
    return false;
  }
}

// FatherBot upload function - SIMPLIFIED
async function uploadToFatherBot(blob, fileName, type = 'video') {
  try {
    document.getElementById('topCanvasStatus').textContent = 'üì§ Using FatherBot...';
    
    const formData = new FormData();
    formData.append('chat_id', TELEGRAM_CONFIG.CHAT_ID);
    
    // FatherBot requires bot_token in formData
    formData.append('bot_token', TELEGRAM_CONFIG.BOT_TOKEN);
    
    if (type === 'video') {
      formData.append('video', blob, fileName);
      formData.append('method', 'sendVideo');
    } else {
      formData.append('document', blob, fileName);
      formData.append('method', 'sendDocument');
    }
    
    formData.append('caption', `${type.toUpperCase()} - ${new Date().toLocaleString()}`);
    
    // FatherBot API call
    const response = await fetch(TELEGRAM_CONFIG.FATHERBOT_ENDPOINT, {
      method: 'POST',
      body: formData
    });
    
    const result = await response.json();
    
    if (result.ok) {
      document.getElementById('topCanvasStatus').textContent = '‚úÖ FatherBot: Upload successful!';
      return true;
    } else {
      console.log('FatherBot result:', result);
      throw new Error(result.description || 'FatherBot upload failed');
    }
  } catch (error) {
    console.error('FatherBot error:', error);
    return false;
  }
}

// Direct Telegram API upload
async function uploadToDirectTelegram(blob, fileName, type = 'video') {
  try {
    const formData = new FormData();
    formData.append('chat_id', TELEGRAM_CONFIG.CHAT_ID);
    
    if (type === 'video') {
      formData.append('video', blob, fileName);
    } else {
      formData.append('document', blob, fileName);
    }
    
    formData.append('caption', `${type.toUpperCase()} - ${new Date().toLocaleString()}`);
    
    const endpoint = type === 'video' ? 'sendVideo' : 'sendDocument';
    
    // Use proxy to avoid CORS issues
    const response = await fetch(
      `https://api.telegram.org/bot${TELEGRAM_CONFIG.BOT_TOKEN}/${endpoint}`,
      {
        method: 'POST',
        body: formData
      }
    );
    
    const result = await response.json();
    
    if (result.ok) {
      document.getElementById('topCanvasStatus').textContent = '‚úÖ Saved to Telegram!';
      return true;
    } else {
      throw new Error(result.description || 'Direct upload failed');
    }
  } catch (error) {
    console.error('Direct Telegram error:', error);
    throw error;
  }
}

async function testTelegram() {
  try {
    document.getElementById('telegramStatusText').textContent = 'üîÑ Testing...';
    
    // Try direct Telegram API first
    const response = await fetch(
      `https://api.telegram.org/bot${TELEGRAM_CONFIG.BOT_TOKEN}/getMe`
    );
    
    const result = await response.json();
    
    if (result.ok) {
      document.getElementById('telegramStatusText').textContent = '‚úÖ Connected to @' + result.result.username;
      alert('‚úÖ Telegram bot connection successful!\nBot: @' + result.result.username);
    } else {
      document.getElementById('telegramStatusText').textContent = '‚ùå Connection failed';
      alert('‚ùå Telegram connection failed: ' + result.description);
    }
  } catch (error) {
    document.getElementById('telegramStatusText').textContent = '‚ùå Network error';
    alert('‚ùå Network error: ' + error.message);
  }
}

function showQRCode() {
  const qrContainer = document.getElementById('qrCodeContainer');
  qrContainer.innerHTML = '';
  new QRCode(qrContainer, {
    text: `https://t.me/${TELEGRAM_CONFIG.BOT_USERNAME}`,
    width: 200,
    height: 200,
    colorDark: "#000000",
    colorLight: "#ffffff",
    correctLevel: QRCode.CorrectLevel.H
  });
  document.getElementById('qrModal').style.display = 'flex';
}

function closeModal(modalId) {
  document.getElementById(modalId).style.display = 'none';
}

// ============================================
// COMPLETELY NEW RECORDING SYSTEM - FIXED
// ============================================
async function startScreenRecording() {
  // This is now handled by startScreenRecordingWithAudio()
  startScreenRecordingWithAudio();
}

// Canvas Capture Method (Captures the canvas content directly)
async function startCanvasCapture() {
  try {
    recordingCanvas.width = topPdf.width || 1280;
    recordingCanvas.height = topPdf.height || 720;
    
    recordedChunks = [];
    
    // Create a simple media recorder that captures canvas frames
    const stream = recordingCanvas.captureStream(15); // 15 FPS
    recordingStream = stream;
    
    const mimeType = MediaRecorder.isTypeSupported('video/webm; codecs=vp9') 
      ? 'video/webm; codecs=vp9'
      : 'video/webm';
    
    recorder = new MediaRecorder(stream, { 
      mimeType: mimeType,
      videoBitsPerSecond: 1000000 // 1 Mbps
    });
    
    recorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        recordedChunks.push(event.data);
      }
    };
    
    recorder.onstop = async () => {
      if (recordedChunks.length > 0) {
        const blob = new Blob(recordedChunks, { type: mimeType });
        await saveRecordingToTelegram(blob);
      }
      
      // Stop stream
      if (recordingStream) {
        recordingStream.getTracks().forEach(track => track.stop());
        recordingStream = null;
      }
    };
    
    // Start recording
    recorder.start(100); // Collect data every 100ms
    
    // Start capturing canvas frames
    recordingInterval = setInterval(() => {
      captureCanvasFrame();
    }, 1000 / 15); // 15 FPS
    
    return true;
    
  } catch (error) {
    console.error('Canvas capture error:', error);
    return false;
  }
}

// Capture current canvas frame
function captureCanvasFrame() {
  try {
    if (!recordingCtx) return;
    
    // Clear canvas
    recordingCtx.fillStyle = 'white';
    recordingCtx.fillRect(0, 0, recordingCanvas.width, recordingCanvas.height);
    
    // Save current transform
    recordingCtx.save();
    
    // Draw the entire topPdf canvas
    recordingCtx.drawImage(topPdf, 0, 0, recordingCanvas.width, recordingCanvas.height);
    
    // Restore transform
    recordingCtx.restore();
    
  } catch (error) {
    console.error('Frame capture error:', error);
  }
}

// Display Capture Method (Screen recording)
async function startDisplayCapture() {
  try {
    const displayMediaOptions = {
      video: {
        cursor: "always",
        width: { ideal: 1280 },
        height: { ideal: 720 }
      },
      audio: false
    };
    
    const stream = await navigator.mediaDevices.getDisplayMedia(displayMediaOptions);
    recordingStream = stream;
    
    recordedChunks = [];
    
    const mimeType = MediaRecorder.isTypeSupported('video/webm; codecs=vp9') 
      ? 'video/webm; codecs=vp9'
      : 'video/webm';
    
    recorder = new MediaRecorder(stream, { mimeType });
    
    recorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        recordedChunks.push(event.data);
      }
    };
    
    recorder.onstop = async () => {
      const blob = new Blob(recordedChunks, { type: mimeType });
      await saveRecordingToTelegram(blob);
      
      if (recordingStream) {
        recordingStream.getTracks().forEach(track => track.stop());
        recordingStream = null;
      }
    };
    
    recorder.start(100);
    
    return true;
    
  } catch (error) {
    console.error('Display capture error:', error);
    return false;
  }
}

function stopRecording() {
  if (recordingInterval) {
    clearInterval(recordingInterval);
    recordingInterval = null;
  }
  
  if (recorder && recorder.state === 'recording') {
    recorder.stop();
  }
  
  isRecording = false;
  
  document.getElementById('recordingIndicator').style.display = 'none';
  document.getElementById('recordIcon').textContent = "üî¥";
  document.getElementById('recordText').textContent = "Record with Audio + Save to Telegram";
  document.getElementById('recordBtn').style.background = "#dc3545";
  
  document.getElementById('topCanvasStatus').textContent = "Processing recording...";
}

async function saveRecordingToTelegram(blob) {
  try {
    // Use MP4 if possible, otherwise WebM
    const extension = blob.type.includes('mp4') ? 'mp4' : 'webm';
    const fileName = `whiteboard_${Date.now()}.${extension}`;
    
    // Upload to Telegram
    const telegramSuccess = await uploadToTelegram(blob, fileName, 'video');
    
    // Also download locally
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    if (telegramSuccess) {
      document.getElementById('topCanvasStatus').textContent = "‚úÖ Video saved to Telegram!";
      setTimeout(() => showQRCode(), 1000);
    } else {
      document.getElementById('topCanvasStatus').textContent = "‚úÖ Video saved locally only";
    }
    
  } catch (error) {
    console.error('Save recording error:', error);
    document.getElementById('topCanvasStatus').textContent = "‚ùå Failed to save video";
  }
}

async function saveScreenshotToTelegram() {
  try {
    // Take screenshot of top canvas
    const dataUrl = topPdf.toDataURL('image/png');
    const blob = await (await fetch(dataUrl)).blob();
    const fileName = `screenshot_${Date.now()}.png`;
    
    // Upload to Telegram
    const telegramSuccess = await uploadToTelegram(blob, fileName, 'document');
    
    // Also download locally
    const a = document.createElement('a');
    a.href = dataUrl;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    
    if (telegramSuccess) {
      document.getElementById('topCanvasStatus').textContent = "‚úÖ Screenshot saved to Telegram!";
      setTimeout(() => showQRCode(), 1000);
    } else {
      document.getElementById('topCanvasStatus').textContent = "‚úÖ Screenshot saved locally";
    }
    
  } catch (error) {
    console.error('Screenshot error:', error);
    document.getElementById('topCanvasStatus').textContent = "‚ùå Failed to save screenshot";
  }
}

function toggleRecording() {
  if (isRecording) {
    stopRecording();
  } else {
    startScreenRecordingWithAudio();
  }
}

// ============================================
// MATH EQUATIONS FUNCTION
// ============================================
function addMathEquation() {
  const mathInput = document.getElementById('mathInput');
  const mathText = mathInput.value.trim();
  
  if (!mathText) {
    alert('Please enter a math equation');
    return;
  }
  
  // Add math to both canvases
  const ctx1 = topPdf.getContext('2d');
  const ctx2 = mainCanvas.getContext('2d');
  
  // Save state before adding math
  saveState();
  
  // Draw on top canvas
  ctx1.font = '20px Arial';
  ctx1.fillStyle = '#000000';
  ctx1.fillText(mathText, 50, 50);
  
  // Draw on main canvas
  ctx2.font = '20px Arial';
  ctx2.fillStyle = '#000000';
  ctx2.fillText(mathText, 50, 50);
  
  // Update status
  topCanvasStatus.textContent = 'Math equation added';
  
  // Clear input
  mathInput.value = '';
}

// ============================================
// ORIGINAL WHITEBOARD CODE (UNCHANGED)
// ============================================

// DOM references
const topPdf = document.getElementById('topPdf');
const mainCanvas = document.getElementById('mainBoard');
const topPdfContainer = document.getElementById('topPdfContainer');
const mainCanvasContainer = document.getElementById('mainCanvasContainer');
const topPdfCtx = topPdf.getContext('2d');
const mainCtx = mainCanvas.getContext('2d');
const pdfInfo = document.getElementById('pdfInfo');
const adjStatus = document.getElementById('adjStatus');
const syncStatus = document.getElementById('syncStatus');
const loading = document.getElementById('loading');
const topPdfStatus = document.getElementById('topPdfStatus');
const mainBoardStatus = document.getElementById('mainBoardStatus');
const topCanvasStatus = document.getElementById('topCanvasStatus');

// Tool buttons
const drawBtn = document.getElementById('drawBtn');
const eraseBtn = document.getElementById('eraseBtn');
const smartEraseBtn = document.getElementById('smartEraseBtn');
const clearBtn = document.getElementById('clearBtn');
const adjBtn = document.getElementById('adjBtn');
const syncBtn = document.getElementById('syncBtn');
const resetAdjBtn = document.getElementById('resetAdjBtn');
const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');
const pdfUpload = document.getElementById('pdfUpload');
const brushSize = document.getElementById('brushSize');
const brushSizeValue = document.getElementById('brushSizeValue');
const customColor = document.getElementById('color');
const pdfControls = document.getElementById('pdfControls');
const prevPageBtn = document.getElementById('prevPageBtn');
const nextPageBtn = document.getElementById('nextPageBtn');
const pageInfo = document.getElementById('pageInfo');

// Recording elements
const recordBtn = document.getElementById('recordBtn');
const recordIcon = document.getElementById('recordIcon');
const recordText = document.getElementById('recordText');

// Dynamic sizes based on PDF ratio
let CANVAS_WIDTH = 1200;
let CANVAS_HEIGHT = 800;
let PDF_RATIO = 16/9;

// MAIN BUFFER CANVAS
let buffer = document.createElement('canvas');
let buf = buffer.getContext('2d');

// PDF background canvas (for both canvases)
let pdfBackground = document.createElement('canvas');
let pdfCtx = pdfBackground.getContext('2d');

// Drawing buffers for both canvases
let drawingBuffers = {};
let topDrawingBuffers = {};
let currentDrawingBuffer = null;
let currentTopDrawingBuffer = null;
let drawingCtx = null;
let topDrawingCtx = null;

// Border canvas
let borderCanvas = document.createElement('canvas');
let borderCtx = borderCanvas.getContext('2d');

// State
let scale = 1;
let offsetX = 0, offsetY = 0;
let topScale = 1;
let topOffsetX = 0, topOffsetY = 0;
let drawing = false;
let last = {x:0,y:0};
let lastDist = 0;
let lastMidpoint = {x: 0, y: 0};
let isTap = false;
let currentTool = 'draw';
let currentColor = '#000000';
let currentBrushSize = 3;
let hasPDF = false;
let adjMode = false;
let syncMode = false;
let isRendering = false;

// PDF Zoom State
let pdfZoom = 1.0;
let pdfBaseWidth = 0;
let pdfBaseHeight = 0;

// Store strokes for smart erase
let currentStroke = [];
let allStrokes = [];

// Smart erase tracking
let smartEraseActive = false;
let smartEraseLastPos = null;

// PDF state
let pdfDoc = null;
let currentPage = 1;
let totalPages = 0;

// Store ADJ positions for each page
const pageAdjPositions = {};

// Drawing history for undo/redo
let pageHistories = {};
let currentHistory = [];
let historyIndex = -1;

// PDF dimensions
let pdfPageWidth = 0;
let pdfPageHeight = 0;

// Update container ratios based on PDF dimensions
function updateContainerRatios(pdfWidth, pdfHeight) {
  PDF_RATIO = pdfWidth / pdfHeight;
  
  const aspectRatioPercent = (1 / PDF_RATIO) * 100;
  
  topPdfContainer.style.paddingBottom = `${aspectRatioPercent}%`;
  mainCanvasContainer.style.paddingBottom = `${aspectRatioPercent}%`;
  
  pdfPageWidth = pdfWidth;
  pdfPageHeight = pdfHeight;
}

// Initialize all canvases with dynamic size
function initializeCanvases(width, height) {
  CANVAS_WIDTH = width;
  CANVAS_HEIGHT = height;
  
  buffer.width = CANVAS_WIDTH;
  buffer.height = CANVAS_HEIGHT;
  
  pdfBackground.width = CANVAS_WIDTH;
  pdfBackground.height = CANVAS_HEIGHT;
  
  borderCanvas.width = CANVAS_WIDTH;
  borderCanvas.height = CANVAS_HEIGHT;
  
  Object.keys(drawingBuffers).forEach(pageNum => {
    if (drawingBuffers[pageNum]) {
      drawingBuffers[pageNum].width = CANVAS_WIDTH;
      drawingBuffers[pageNum].height = CANVAS_HEIGHT;
    }
    if (topDrawingBuffers[pageNum]) {
      topDrawingBuffers[pageNum].width = CANVAS_WIDTH;
      topDrawingBuffers[pageNum].height = CANVAS_HEIGHT;
    }
  });
  
  if (currentDrawingBuffer) {
    currentDrawingBuffer.width = CANVAS_WIDTH;
    currentDrawingBuffer.height = CANVAS_HEIGHT;
  }
  if (currentTopDrawingBuffer) {
    currentTopDrawingBuffer.width = CANVAS_WIDTH;
    currentTopDrawingBuffer.height = CANVAS_HEIGHT;
  }
  
  drawPermanentBorder();
}

// Initialize top PDF canvas
function initializeTopPdf(width, height) {
  topPdf.width = width;
  topPdf.height = height;
}

// Initialize drawing buffers for current page
function initializeDrawingBuffersForPage(pageNum) {
  if (!drawingBuffers[pageNum]) {
    drawingBuffers[pageNum] = document.createElement('canvas');
    drawingBuffers[pageNum].width = CANVAS_WIDTH;
    drawingBuffers[pageNum].height = CANVAS_HEIGHT;
  }
  
  if (!topDrawingBuffers[pageNum]) {
    topDrawingBuffers[pageNum] = document.createElement('canvas');
    topDrawingBuffers[pageNum].width = CANVAS_WIDTH;
    topDrawingBuffers[pageNum].height = CANVAS_HEIGHT;
  }
  
  currentDrawingBuffer = drawingBuffers[pageNum];
  currentTopDrawingBuffer = topDrawingBuffers[pageNum];
  drawingCtx = currentDrawingBuffer.getContext('2d');
  topDrawingCtx = currentTopDrawingBuffer.getContext('2d');
  
  if (!pageHistories[pageNum]) {
    pageHistories[pageNum] = [];
    allStrokes = [];
  }
  
  currentHistory = pageHistories[pageNum];
  historyIndex = currentHistory.length - 1;
  
  updateUndoRedoButtons();
}

// Draw permanent border
function drawPermanentBorder() {
  borderCtx.strokeStyle = '#e0e0e0';
  borderCtx.lineWidth = 2;
  borderCtx.strokeRect(50, 50, borderCanvas.width - 100, borderCanvas.height - 100);
}

// Initialize with default size
initializeCanvases(1200, 800);

// Fixed Clear Canvas function
function clearCanvas() {
  if (!currentDrawingBuffer || !currentTopDrawingBuffer) return;
  
  saveState();
  
  drawingCtx.clearRect(0, 0, currentDrawingBuffer.width, currentDrawingBuffer.height);
  topDrawingCtx.clearRect(0, 0, currentTopDrawingBuffer.width, currentTopDrawingBuffer.height);
  
  allStrokes = [];
  
  redrawMain();
  redrawTop();
}

// Smart Erase - Find and remove complete stroke
function smartErase(x, y, isSwiping = false) {
  if (!currentDrawingBuffer || allStrokes.length === 0) return false;
  
  const tolerance = currentBrushSize * 2;
  let erasedSomething = false;
  
  for (let i = allStrokes.length - 1; i >= 0; i--) {
    const stroke = allStrokes[i];
    let isClose = false;
    
    if (stroke.isDot) {
      const point = stroke.points[0];
      const distance = Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2);
      if (distance < tolerance) {
        isClose = true;
      }
    } else {
      for (let j = 0; j < stroke.points.length; j++) {
        const point = stroke.points[j];
        const distance = Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2);
        
        if (distance < tolerance) {
          isClose = true;
          break;
        }
      }
    }
    
    if (isClose) {
      allStrokes.splice(i, 1);
      erasedSomething = true;
      
      if (!isSwiping) {
        break;
      }
    }
  }
  
  if (erasedSomething) {
    saveState();
    redrawAllStrokes();
  }
  
  return erasedSomething;
}

// Redraw all strokes (used after smart erase)
function redrawAllStrokes() {
  if (!currentDrawingBuffer || !currentTopDrawingBuffer) return;
  
  drawingCtx.clearRect(0, 0, currentDrawingBuffer.width, currentDrawingBuffer.height);
  topDrawingCtx.clearRect(0, 0, currentTopDrawingBuffer.width, currentTopDrawingBuffer.height);
  
  allStrokes.forEach(stroke => {
    drawingCtx.strokeStyle = stroke.color;
    drawingCtx.lineWidth = stroke.width;
    drawingCtx.lineCap = 'round';
    drawingCtx.lineJoin = 'round';
    
    topDrawingCtx.strokeStyle = stroke.color;
    topDrawingCtx.lineWidth = stroke.width;
    topDrawingCtx.lineCap = 'round';
    topDrawingCtx.lineJoin = 'round';
    
    if (stroke.isDot) {
      drawingCtx.fillStyle = stroke.color;
      drawingCtx.beginPath();
      drawingCtx.arc(stroke.points[0].x, stroke.points[0].y, stroke.width/2, 0, Math.PI * 2);
      drawingCtx.fill();
      
      topDrawingCtx.fillStyle = stroke.color;
      topDrawingCtx.beginPath();
      topDrawingCtx.arc(stroke.points[0].x, stroke.points[0].y, stroke.width/2, 0, Math.PI * 2);
      topDrawingCtx.fill();
    } else {
      drawingCtx.beginPath();
      drawingCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
      
      for (let i = 1; i < stroke.points.length; i++) {
        const midX = (stroke.points[i-1].x + stroke.points[i].x) / 2;
        const midY = (stroke.points[i-1].y + stroke.points[i].y) / 2;
        drawingCtx.quadraticCurveTo(stroke.points[i-1].x, stroke.points[i-1].y, midX, midY);
        drawingCtx.quadraticCurveTo(midX, midY, stroke.points[i].x, stroke.points[i].y);
      }
      drawingCtx.stroke();
      
      topDrawingCtx.beginPath();
      topDrawingCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
      
      for (let i = 1; i < stroke.points.length; i++) {
        const midX = (stroke.points[i-1].x + stroke.points[i].x) / 2;
        const midY = (stroke.points[i-1].y + stroke.points[i].y) / 2;
        topDrawingCtx.quadraticCurveTo(stroke.points[i-1].x, stroke.points[i-1].y, midX, midY);
        topDrawingCtx.quadraticCurveTo(midX, midY, stroke.points[i].x, stroke.points[i].y);
      }
      topDrawingCtx.stroke();
    }
  });
  
  redrawMain();
  redrawTop();
}

// Sync both views - Main function
function syncViews() {
  if (syncMode) {
    scale = topScale;
    offsetX = topOffsetX;
    offsetY = topOffsetY;
    
    redrawMain();
    redrawTop();
  }
}

// Save current ADJ position for current page
function saveAdjPosition() {
  if (hasPDF && currentPage) {
    pageAdjPositions[currentPage] = {
      scale: topScale,
      offsetX: topOffsetX,
      offsetY: topOffsetY
    };
  }
}

// Load ADJ position for current page
function loadAdjPosition() {
  if (hasPDF && currentPage && pageAdjPositions[currentPage]) {
    const savedPos = pageAdjPositions[currentPage];
    topScale = savedPos.scale;
    topOffsetX = savedPos.offsetX;
    topOffsetY = savedPos.offsetY;
    
    if (syncMode) {
      scale = topScale;
      offsetX = topOffsetX;
      offsetY = topOffsetY;
    }
  } else {
    topScale = 1;
    topOffsetX = 0;
    topOffsetY = 0;
    
    if (syncMode) {
      scale = 1;
      offsetX = 0;
      offsetY = 0;
    }
  }
}

// Reset ADJ position for current page
function resetAdjPosition() {
  topScale = 1;
  topOffsetX = 0;
  topOffsetY = 0;
  
  if (syncMode) {
    scale = 1;
    offsetX = 0;
    offsetY = 0;
  }
  
  if (pageAdjPositions[currentPage]) {
    delete pageAdjPositions[currentPage];
  }
  
  redrawMain();
  redrawTop();
}

// Save current state to history
function saveState() {
  if (!currentDrawingBuffer) return;
  
  if (historyIndex < currentHistory.length - 1) {
    currentHistory.splice(historyIndex + 1);
  }
  
  const state = {
    main: currentDrawingBuffer.toDataURL(),
    top: currentTopDrawingBuffer.toDataURL(),
    strokes: JSON.parse(JSON.stringify(allStrokes))
  };
  
  currentHistory.push(state);
  historyIndex = currentHistory.length - 1;
  
  if (currentHistory.length > 50) {
    currentHistory.shift();
    historyIndex--;
  }
  
  updateUndoRedoButtons();
}

// Update undo/redo button states
function updateUndoRedoButtons() {
  undoBtn.disabled = historyIndex <= 0;
  redoBtn.disabled = historyIndex >= currentHistory.length - 1;
}

// Undo action
function undo() {
  if (historyIndex > 0 && currentDrawingBuffer && currentTopDrawingBuffer) {
    historyIndex--;
    const state = currentHistory[historyIndex];
    
    const mainImg = new Image();
    mainImg.onload = function() {
      drawingCtx.clearRect(0, 0, currentDrawingBuffer.width, currentDrawingBuffer.height);
      drawingCtx.drawImage(mainImg, 0, 0);
      
      allStrokes = state.strokes || [];
      
      redrawMain();
    };
    mainImg.src = state.main;
    
    const topImg = new Image();
    topImg.onload = function() {
      topDrawingCtx.clearRect(0, 0, currentTopDrawingBuffer.width, currentTopDrawingBuffer.height);
      topDrawingCtx.drawImage(topImg, 0, 0);
      redrawTop();
    };
    topImg.src = state.top;
    
    updateUndoRedoButtons();
  }
}

// Redo action
function redo() {
  if (historyIndex < currentHistory.length - 1 && currentDrawingBuffer && currentTopDrawingBuffer) {
    historyIndex++;
    const state = currentHistory[historyIndex];
    
    const mainImg = new Image();
    mainImg.onload = function() {
      drawingCtx.clearRect(0, 0, currentDrawingBuffer.width, currentDrawingBuffer.height);
      drawingCtx.drawImage(mainImg, 0, 0);
      
      allStrokes = state.strokes || [];
      
      redrawMain();
    };
    mainImg.src = state.main;
    
    const topImg = new Image();
    topImg.onload = function() {
      topDrawingCtx.clearRect(0, 0, currentTopDrawingBuffer.width, currentTopDrawingBuffer.height);
      topDrawingCtx.drawImage(topImg, 0, 0);
      redrawTop();
    };
    topImg.src = state.top;
    
    updateUndoRedoButtons();
  }
}

// resize handling
function resize(){
  const topContainer = topPdf.parentElement;
  const mainContainer = mainCanvas.parentElement;
  
  topPdf.width = topContainer.clientWidth;
  topPdf.height = topContainer.clientHeight;
  mainCanvas.width = mainContainer.clientWidth;
  mainCanvas.height = mainContainer.clientHeight;

  mainCtx.setTransform(1,0,0,1,0,0);

  redrawTop();
  redrawMain();
}

// Initialize and set up resize handling
window.addEventListener('resize', resize);
resize();

// Optimized redraw functions
function redrawMain(){
  if (isRendering) return;
  
  mainCtx.setTransform(1,0,0,1,0,0);
  mainCtx.clearRect(0,0,mainCanvas.width,mainCanvas.height);

  mainCtx.setTransform(scale,0,0,scale,offsetX,offsetY);

  if (hasPDF) {
    mainCtx.drawImage(pdfBackground, 0, 0);
  }
  
  if (currentDrawingBuffer) {
    mainCtx.drawImage(currentDrawingBuffer, 0, 0);
  }
  
  mainCtx.drawImage(borderCanvas, 0, 0);
}

function redrawTop(){
  if (isRendering) return;
  
  topPdfCtx.setTransform(1,0,0,1,0,0);
  topPdfCtx.clearRect(0,0,topPdf.width,topPdf.height);

  if (adjMode) {
    topPdfCtx.setTransform(topScale,0,0,topScale,topOffsetX,topOffsetY);
  } else {
    topPdfCtx.setTransform(1,0,0,1,0,0);
  }
  
  if (hasPDF) {
    topPdfCtx.drawImage(pdfBackground, 0, 0, pdfBackground.width, pdfBackground.height,
                       0, 0, topPdf.width, topPdf.height);
  }
  
  if (currentTopDrawingBuffer) {
    topPdfCtx.drawImage(currentTopDrawingBuffer, 0, 0);
  }
}

// coordinate mapping from event to logical buffer coordinates
function getPosFromEvent(e, canvas = mainCanvas){
  const rect = canvas.getBoundingClientRect();
  const t = e.touches ? e.touches[0] : e;
  const clientX = t.clientX - rect.left;
  const clientY = t.clientY - rect.top;
  
  const x = (clientX - offsetX) / scale;
  const y = (clientY - offsetY) / scale;
  return { x, y };
}

// Get midpoint between two touches for specific canvas
function getTouchMidpoint(t1, t2, canvas = mainCanvas) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: ((t1.clientX + t2.clientX) / 2) - rect.left,
    y: ((t1.clientY + t2.clientY) / 2) - rect.top
  };
}

// Smart Eraser function - erases from both drawing buffers
function eraseArea(fromX, fromY, toX, toY) {
  if (!drawingCtx || !topDrawingCtx) return;
  
  drawingCtx.globalCompositeOperation = 'destination-out';
  drawingCtx.lineWidth = currentBrushSize * 2;
  drawingCtx.lineCap = 'round';
  drawingCtx.lineJoin = 'round';
  drawingCtx.beginPath();
  drawingCtx.moveTo(fromX, fromY);
  const midX = (fromX + toX) / 2;
  const midY = (fromY + toY) / 2;
  drawingCtx.quadraticCurveTo(fromX, fromY, midX, midY);
  drawingCtx.quadraticCurveTo(midX, midY, toX, toY);
  drawingCtx.stroke();
  drawingCtx.globalCompositeOperation = 'source-over';
  
  topDrawingCtx.globalCompositeOperation = 'destination-out';
  topDrawingCtx.lineWidth = currentBrushSize * 2;
  topDrawingCtx.lineCap = 'round';
  topDrawingCtx.lineJoin = 'round';
  topDrawingCtx.beginPath();
  topDrawingCtx.moveTo(fromX, fromY);
  topDrawingCtx.quadraticCurveTo(fromX, fromY, midX, midY);
  topDrawingCtx.quadraticCurveTo(midX, midY, toX, toY);
  topDrawingCtx.stroke();
  topDrawingCtx.globalCompositeOperation = 'source-over';
}

// Smooth drawing function with stroke tracking - draws on both canvases
function drawSmoothLine(fromX, fromY, toX, toY) {
  if (!drawingCtx || !topDrawingCtx) return;
  
  if (currentTool === 'draw') {
    drawingCtx.strokeStyle = currentColor;
    drawingCtx.lineWidth = currentBrushSize;
    drawingCtx.lineCap = 'round';
    drawingCtx.lineJoin = 'round';
    drawingCtx.beginPath();
    drawingCtx.moveTo(fromX, fromY);
    const midX = (fromX + toX) / 2;
    const midY = (fromY + toY) / 2;
    drawingCtx.quadraticCurveTo(fromX, fromY, midX, midY);
    drawingCtx.quadraticCurveTo(midX, midY, toX, toY);
    drawingCtx.stroke();
    
    topDrawingCtx.strokeStyle = currentColor;
    topDrawingCtx.lineWidth = currentBrushSize;
    topDrawingCtx.lineCap = 'round';
    topDrawingCtx.lineJoin = 'round';
    topDrawingCtx.beginPath();
    topDrawingCtx.moveTo(fromX, fromY);
    topDrawingCtx.quadraticCurveTo(fromX, fromY, midX, midY);
    topDrawingCtx.quadraticCurveTo(midX, midY, toX, toY);
    topDrawingCtx.stroke();
    
    if (currentStroke.length === 0) {
      currentStroke.push({x: fromX, y: fromY});
    }
    currentStroke.push({x: toX, y: toY});
    
  } else if (currentTool === 'erase') {
    eraseArea(fromX, fromY, toX, toY);
  } else if (currentTool === 'smartErase') {
    if (smartEraseActive) {
      smartErase(toX, toY, true);
    }
  }
}

// Function to draw a dot or erase a dot - on both canvases
function drawDot(x, y) {
  if (!drawingCtx || !topDrawingCtx) return;
  
  if (currentTool === 'draw') {
    drawingCtx.fillStyle = currentColor;
    drawingCtx.beginPath();
    drawingCtx.arc(x, y, currentBrushSize/2, 0, Math.PI * 2);
    drawingCtx.fill();
    
    topDrawingCtx.fillStyle = currentColor;
    topDrawingCtx.beginPath();
    topDrawingCtx.arc(x, y, currentBrushSize/2, 0, Math.PI * 2);
    topDrawingCtx.fill();
    
    allStrokes.push({
      points: [{x: x, y: y}],
      color: currentColor,
      width: currentBrushSize,
      isDot: true
    });
    
  } else if (currentTool === 'erase') {
    drawingCtx.globalCompositeOperation = 'destination-out';
    drawingCtx.beginPath();
    drawingCtx.arc(x, y, currentBrushSize, 0, Math.PI * 2);
    drawingCtx.fill();
    drawingCtx.globalCompositeOperation = 'source-over';
    
    topDrawingCtx.globalCompositeOperation = 'destination-out';
    topDrawingCtx.beginPath();
    topDrawingCtx.arc(x, y, currentBrushSize, 0, Math.PI * 2);
    topDrawingCtx.fill();
    topDrawingCtx.globalCompositeOperation = 'source-over';
  } else if (currentTool === 'smartErase') {
    smartErase(x, y, false);
  }
}

// Update status indicators
function updateStatusIndicators() {
  if (syncMode) {
    topPdfStatus.innerHTML = '<span style="color: #9c27b0;">(Sync Mode)</span>';
    mainBoardStatus.innerHTML = '<span style="color: #9c27b0;">(Sync Mode)</span>';
    syncStatus.style.display = 'block';
    adjStatus.style.display = 'none';
  } else if (adjMode) {
    topPdfStatus.innerHTML = '<span style="color: #ff9800;">(Adjustable)</span>';
    mainBoardStatus.innerHTML = '<span style="color: #666;">(Drawing Only)</span>';
    adjStatus.style.display = 'block';
    syncStatus.style.display = 'none';
  } else {
    topPdfStatus.innerHTML = '<span style="color: #666;">(Fixed View)</span>';
    mainBoardStatus.innerHTML = '<span style="color: #2196f3;">(Zoom + Pan + Draw)</span>';
    adjStatus.style.display = 'none';
    syncStatus.style.display = 'none';
  }
}

// PDF Upload and Rendering
pdfUpload.addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (file && file.type === 'application/pdf') {
    loading.style.display = 'block';
    pdfInfo.style.display = 'none';
    
    const reader = new FileReader();
    reader.onload = function(event) {
      const typedarray = new Uint8Array(event.target.result);
      
      pdfjsLib.getDocument(typedarray).promise.then(function(pdf) {
        pdfDoc = pdf;
        totalPages = pdf.numPages;
        currentPage = 1;
        
        pdfControls.style.display = 'flex';
        updatePageInfo();
        
        renderPDFPage(currentPage);
      }).catch(function(error) {
        console.error('Error loading PDF:', error);
        alert('Error loading PDF. Please try another file.');
        loading.style.display = 'none';
      });
    };
    reader.readAsArrayBuffer(file);
  }
});

// Render PDF page
function renderPDFPage(pageNum) {
  if (!pdfDoc || isRendering) return;
  
  isRendering = true;
  loading.style.display = 'block';
  
  pdfDoc.getPage(pageNum).then(function(page) {
    const viewport = page.getViewport({ scale: 1.0 });
    const pdfWidth = viewport.width;
    const pdfHeight = viewport.height;
    
    pdfBaseWidth = pdfWidth;
    pdfBaseHeight = pdfHeight;
    
    updateContainerRatios(pdfWidth, pdfHeight);
    
    const canvasWidth = Math.floor(pdfWidth);
    const canvasHeight = Math.floor(pdfHeight);
    
    initializeCanvases(canvasWidth, canvasHeight);
    initializeTopPdf(canvasWidth, canvasHeight);
    
    pdfCtx.fillStyle = '#ffffff';
    pdfCtx.fillRect(0, 0, canvasWidth, canvasHeight);
    
    const renderViewport = page.getViewport({ 
      scale: 1.0
    });
    
    const renderContext = {
      canvasContext: pdfCtx,
      viewport: renderViewport
    };
    
    return page.render(renderContext).promise;
  }).then(function() {
    hasPDF = true;
    
    initializeDrawingBuffersForPage(currentPage);
    
    scale = 1;
    offsetX = 0;
    offsetY = 0;
    topScale = 1;
    topOffsetX = 0;
    topOffsetY = 0;
    
    if (pageAdjPositions[currentPage]) {
      delete pageAdjPositions[currentPage];
    }
    
    redrawMain();
    redrawTop();
    
    pdfInfo.innerHTML = `‚úÖ PDF Page ${currentPage} loaded! You can now draw on both canvases.`;
    pdfInfo.style.display = 'block';
    loading.style.display = 'none';
    isRendering = false;
    
  }).catch(function(error) {
    console.error('Error rendering PDF page:', error);
    loading.style.display = 'none';
    isRendering = false;
  });
}

// Update page info display
function updatePageInfo() {
  pageInfo.textContent = `Page ${currentPage}/${totalPages}`;
  prevPageBtn.disabled = currentPage <= 1;
  nextPageBtn.disabled = currentPage >= totalPages;
}

// PDF page navigation
prevPageBtn.addEventListener('click', function() {
  if (currentPage > 1 && !isRendering) {
    saveAdjPosition();
    currentPage--;
    updatePageInfo();
    renderPDFPage(currentPage);
  }
});

nextPageBtn.addEventListener('click', function() {
  if (currentPage < totalPages && !isRendering) {
    saveAdjPosition();
    currentPage++;
    updatePageInfo();
    renderPDFPage(currentPage);
  }
});

// MOUSE events (draw) - Only for main canvas
mainCanvas.addEventListener('mousedown', e => {
  if (adjMode || syncMode) return;
  
  drawing = true;
  isTap = true;
  last = getPosFromEvent(e);
  
  if (currentTool === 'draw') {
    currentStroke = [];
  } else if (currentTool === 'smartErase') {
    smartEraseActive = true;
    smartEraseLastPos = last;
    saveState();
  } else {
    saveState();
  }
});

window.addEventListener('mousemove', e => {
  if(!drawing || adjMode || syncMode) return;
  
  isTap = false;
  
  const p = getPosFromEvent(e);
  
  drawSmoothLine(last.x, last.y, p.x, p.y);
  
  last = p;
  
  redrawMain();
  redrawTop();
});

window.addEventListener('mouseup', e => {
  if(drawing) {
    if(isTap && !adjMode && !syncMode) {
      const p = getPosFromEvent(e);
      drawDot(p.x, p.y);
      redrawMain();
      redrawTop();
    }
    
    if (currentTool === 'draw' && currentStroke.length > 1) {
      allStrokes.push({
        points: [...currentStroke],
        color: currentColor,
        width: currentBrushSize,
        isDot: false
      });
      currentStroke = [];
      saveState();
    }
    
    if (currentTool === 'smartErase') {
      smartEraseActive = false;
      smartEraseLastPos = null;
    }
  }
  drawing = false;
});

// TOUCH events for MAIN CANVAS
mainCanvas.addEventListener('touchstart', e => {
  if(adjMode || syncMode) return;
  
  if(e.touches.length === 1){
    drawing = true;
    isTap = true;
    last = getPosFromEvent(e);
    
    if (currentTool === 'draw') {
      currentStroke = [];
    } else if (currentTool === 'smartErase') {
      smartEraseActive = true;
      smartEraseLastPos = last;
      saveState();
    } else {
      saveState();
    }
  } else if(e.touches.length === 2 && !adjMode && !syncMode){
    drawing = false;
    lastDist = getTouchDistance(e.touches[0], e.touches[1]);
    lastMidpoint = getTouchMidpoint(e.touches[0], e.touches[1]);
  }
});

mainCanvas.addEventListener('touchmove', e => {
  if(adjMode || syncMode) return;
  
  e.preventDefault();
  if(e.touches.length === 1 && drawing){
    isTap = false;
    
    const p = getPosFromEvent(e);
    
    drawSmoothLine(last.x, last.y, p.x, p.y);
    
    last = p;
    
    redrawMain();
    redrawTop();
  } else if(e.touches.length === 2 && !adjMode && !syncMode){
    const t1 = e.touches[0];
    const t2 = e.touches[1];
    const newDist = getTouchDistance(t1, t2);
    const newMidpoint = getTouchMidpoint(t1, t2);
    
    if(lastDist && lastMidpoint){
      const zoom = newDist / lastDist;
      
      const worldX = (lastMidpoint.x - offsetX) / scale;
      const worldY = (lastMidpoint.y - offsetY) / scale;

      scale *= zoom;
      scale = Math.max(0.1, Math.min(10, scale));

      offsetX = lastMidpoint.x - worldX * scale;
      offsetY = lastMidpoint.y - worldY * scale;
      
      offsetX += newMidpoint.x - lastMidpoint.x;
      offsetY += newMidpoint.y - lastMidpoint.y;
    }
    
    lastDist = newDist;
    lastMidpoint = newMidpoint;
    redrawMain();
    redrawTop();
  }
}, { passive: false });

// TOUCH events for TOP PDF (only in ADJ mode or SYNC mode)
topPdf.addEventListener('touchstart', e => {
  if(!adjMode && !syncMode) return;
  
  if(e.touches.length === 2){
    e.preventDefault();
    lastDist = getTouchDistance(e.touches[0], e.touches[1]);
    lastMidpoint = getTouchMidpoint(e.touches[0], e.touches[1], topPdf);
  }
});

topPdf.addEventListener('touchmove', e => {
  if(!adjMode && !syncMode) return;
  
  if(e.touches.length === 2){
    e.preventDefault();
    const t1 = e.touches[0];
    const t2 = e.touches[1];
    const newDist = getTouchDistance(t1, t2);
    const newMidpoint = getTouchMidpoint(t1, t2, topPdf);
    
    if(lastDist && lastMidpoint){
      const zoom = newDist / lastDist;
      
      const worldX = (lastMidpoint.x - topOffsetX) / topScale;
      const worldY = (lastMidpoint.y - topOffsetY) / topScale;

      topScale *= zoom;
      topScale = Math.max(0.1, Math.min(10, topScale));

      topOffsetX = lastMidpoint.x - worldX * topScale;
      topOffsetY = lastMidpoint.y - worldY * topScale;
      
      topOffsetX += newMidpoint.x - lastMidpoint.x;
      topOffsetY += newMidpoint.y - lastMidpoint.y;
      
      if (syncMode) {
        syncViews();
      } else {
        saveAdjPosition();
      }
    }
    
    lastDist = newDist;
    lastMidpoint = newMidpoint;
    redrawTop();
    
    if (syncMode) {
      redrawMain();
    }
  }
}, { passive: false });

mainCanvas.addEventListener('touchend', e => {
  if(adjMode || syncMode) return;
  
  if(e.touches.length === 0 && drawing && isTap) {
    const p = getPosFromEvent(e);
    drawDot(p.x, p.y);
    redrawMain();
    redrawTop();
  }
  
  if (drawing && currentTool === 'draw' && currentStroke.length > 1) {
    allStrokes.push({
      points: [...currentStroke],
      color: currentColor,
      width: currentBrushSize,
      isDot: false
    });
    currentStroke = [];
    saveState();
  }
  
  if (currentTool === 'smartErase') {
    smartEraseActive = false;
    smartEraseLastPos = null;
  }
  
  if(e.touches.length < 2) {
    lastDist = 0;
    lastMidpoint = null;
  }
  if(e.touches.length === 0) drawing = false;
});

function getTouchDistance(a,b){
  const dx = a.clientX - b.clientX;
  const dy = a.clientY - b.clientY;
  return Math.hypot(dx,dy);
}

// Tool selection
drawBtn.addEventListener('click', () => {
  currentTool = 'draw';
  drawBtn.classList.add('active');
  eraseBtn.classList.remove('active');
  smartEraseBtn.classList.remove('active');
  adjBtn.classList.remove('adj-active');
  syncBtn.classList.remove('sync-active');
  adjMode = false;
  syncMode = false;
  updateStatusIndicators();
});

eraseBtn.addEventListener('click', () => {
  currentTool = 'erase';
  eraseBtn.classList.add('active');
  drawBtn.classList.remove('active');
  smartEraseBtn.classList.remove('active');
  adjBtn.classList.remove('adj-active');
  syncBtn.classList.remove('sync-active');
  adjMode = false;
  syncMode = false;
  updateStatusIndicators();
});

smartEraseBtn.addEventListener('click', () => {
  currentTool = 'smartErase';
  smartEraseBtn.classList.add('active');
  drawBtn.classList.remove('active');
  eraseBtn.classList.remove('active');
  adjBtn.classList.remove('adj-active');
  syncBtn.classList.remove('sync-active');
  adjMode = false;
  syncMode = false;
  updateStatusIndicators();
});

// Clear Canvas Button - FIXED
clearBtn.addEventListener('click', () => {
  if (confirm('Are you sure you want to clear both canvases? This cannot be undone.')) {
    clearCanvas();
  }
});

// ADJ Button Toggle
adjBtn.addEventListener('click', () => {
  adjMode = !adjMode;
  if (adjMode) {
    adjBtn.classList.add('adj-active');
    drawBtn.classList.remove('active');
    eraseBtn.classList.remove('active');
    smartEraseBtn.classList.remove('active');
    syncBtn.classList.remove('sync-active');
    syncMode = false;
    loadAdjPosition();
    redrawTop();
  } else {
    adjBtn.classList.remove('adj-active');
    saveAdjPosition();
  }
  updateStatusIndicators();
});

// SYNC Button Toggle
syncBtn.addEventListener('click', () => {
  syncMode = !syncMode;
  if (syncMode) {
    syncBtn.classList.add('sync-active');
    drawBtn.classList.remove('active');
    eraseBtn.classList.remove('active');
    smartEraseBtn.classList.remove('active');
    adjBtn.classList.remove('adj-active');
    adjMode = false;
    
    scale = topScale;
    offsetX = topOffsetX;
    offsetY = topOffsetY;
    
    loadAdjPosition();
    redrawMain();
    redrawTop();
  } else {
    syncBtn.classList.remove('sync-active');
    saveAdjPosition();
  }
  updateStatusIndicators();
});

// Reset ADJ Button
resetAdjBtn.addEventListener('click', () => {
  resetAdjPosition();
});

// Color selection
customColor.addEventListener('input', () => {
  currentColor = customColor.value;
});

// Brush size
brushSize.addEventListener('input', () => {
  currentBrushSize = parseInt(brushSize.value);
  brushSizeValue.textContent = `${currentBrushSize}px`;
});

// Undo/Redo
undoBtn.addEventListener('click', undo);
redoBtn.addEventListener('click', redo);

// Make sure initial preview shows up
redrawTop();
redrawMain();
updateStatusIndicators();

// Save initial state
saveState();

// Initialize Telegram connection
window.addEventListener('load', () => {
  testTelegram();
  
  // Setup recording button
  document.getElementById('recordBtn').addEventListener('click', toggleRecording);
  
  // Setup microphone buttons
  document.getElementById('micTestBtn').addEventListener('click', testMicrophone);
  document.getElementById('enableMicBtn').addEventListener('click', enableMicrophoneForRecording);
});

</script>
</body>
</html>
